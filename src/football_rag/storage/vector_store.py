"""ChromaDB wrapper - lets ChromaDB handle embeddings internally.

Simplified VectorStore that relies on ChromaDB's built-in embedding function.
No redundant embedding generation in Python = faster, cleaner, no version conflicts.
"""

import chromadb
from typing import List, Dict, Any, Optional
import logging
from datetime import datetime, timezone

logger = logging.getLogger(__name__)


class VectorStore:
    """Thin wrapper around ChromaDB for football match vector storage.

    ChromaDB handles embeddings internally using its default embedding function.
    This class just provides a clean Python API for add/search/delete operations.

    Args:
        collection_name: Name of the ChromaDB collection
        host: ChromaDB host (for client-server mode)
        port: ChromaDB port (for client-server mode)
        persist_directory: Directory for ChromaDB persistence (local mode)

    Example:
        >>> store = VectorStore(host='localhost', port=8000)
        >>> store.add_documents(
        ...     documents=["Match summary..."],
        ...     metadatas=[{"home_team": "Ajax"}],
        ...     ids=["match_1"]
        ... )
        >>> results = store.search("Ajax attacking", k=5)
    """

    def __init__(
        self,
        collection_name: str = "football_matches_eredivisie_2025",
        host: Optional[str] = None,
        port: Optional[int] = None,
        persist_directory: Optional[str] = "./data/chroma",
    ):
        """Initialize VectorStore with ChromaDB client."""
        # Initialize ChromaDB client
        if host and port:
            logger.info(f"Connecting to ChromaDB at {host}:{port}")
            self.client = chromadb.HttpClient(host=host, port=port)
        else:
            logger.info(f"Using persistent ChromaDB at {persist_directory}")
            self.client = chromadb.PersistentClient(path=persist_directory)

        # Get collection (assume it exists, created externally with correct embedding)
        self.collection_name = collection_name
        try:
            self.collection = self.client.get_collection(name=collection_name)
            logger.info(
                f"✓ Collection '{collection_name}' has {self.collection.count()} documents"
            )
        except Exception as e:
            logger.error(f"Collection '{collection_name}' not found. Create it first.")
            raise

    def add_documents(
        self,
        documents: List[str],
        metadatas: List[Dict[str, Any]],
        ids: List[str],
    ) -> None:
        """Add documents to ChromaDB (embeddings generated by ChromaDB).

        Args:
            documents: List of text documents
            metadatas: List of metadata dicts (one per document)
            ids: List of unique document IDs
        """
        if not (len(documents) == len(metadatas) == len(ids)):
            raise ValueError(
                f"Length mismatch: documents={len(documents)}, "
                f"metadatas={len(metadatas)}, ids={len(ids)}"
            )

        if not documents:
            logger.warning("No documents to add")
            return

        # Add timestamp
        timestamp = datetime.now(timezone.utc).isoformat()
        for metadata in metadatas:
            metadata["ingestion_timestamp"] = timestamp

        # ChromaDB generates embeddings automatically
        logger.info(
            f"Adding {len(documents)} documents (ChromaDB handles embeddings)..."
        )
        self.collection.add(documents=documents, metadatas=metadatas, ids=ids)

        logger.info(
            f"✓ Added {len(documents)} documents. Total: {self.collection.count()}"
        )

    def search(
        self,
        query: str,
        k: int = 5,
        where: Optional[Dict[str, Any]] = None,
    ) -> List[Dict[str, Any]]:
        """Search for similar documents using semantic similarity.

        Args:
            query: Search query text
            k: Number of results to return
            where: Metadata filter (ChromaDB where syntax)

        Returns:
            List of dicts with keys: id, document, metadata, distance

        Example:
            >>> results = store.search("high xG teams", k=5)
            >>> results = store.search(
            ...     "attacking play",
            ...     where={"home_team": "Ajax"}
            ... )
        """
        logger.info(f"Searching: '{query[:50]}...' (k={k})")

        # ChromaDB handles query embedding automatically
        results = self.collection.query(
            query_texts=[query],
            n_results=k,
            where=where,
        )

        # Format results
        formatted = []
        if results["ids"] and results["ids"][0]:
            for i in range(len(results["ids"][0])):
                formatted.append(
                    {
                        "id": results["ids"][0][i],
                        "document": results["documents"][0][i],
                        "metadata": results["metadatas"][0][i],
                        "distance": results["distances"][0][i]
                        if "distances" in results
                        else None,
                    }
                )

        logger.info(f"Found {len(formatted)} results")
        return formatted

    def get_by_id(self, doc_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve document by ID."""
        results = self.collection.get(ids=[doc_id])
        if results["ids"]:
            return {
                "id": results["ids"][0],
                "document": results["documents"][0],
                "metadata": results["metadatas"][0],
            }
        return None

    def delete(self, ids: List[str]) -> None:
        """Delete documents by IDs."""
        logger.info(f"Deleting {len(ids)} documents...")
        self.collection.delete(ids=ids)
        logger.info(f"✓ Deleted. Total: {self.collection.count()}")

    def count(self) -> int:
        """Get total number of documents."""
        return self.collection.count()

    def get_stats(self) -> Dict[str, Any]:
        """Get collection statistics."""
        return {
            "collection_name": self.collection_name,
            "document_count": self.collection.count(),
            "embedding_model": self.collection.metadata.get(
                "embedding_model", "chromadb-default"
            ),
        }
